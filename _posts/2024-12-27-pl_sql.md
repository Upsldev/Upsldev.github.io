---
layout: single
title: "대용량 데이터 안전하게(비교적) 삭제하기(PL/SQL)"
excerpt: "Tibero 대용량 데이터 안전하게(비교적) 삭제하기(PL/SQL)"	
date: 2024-12-27
last_modified_at : 2024-12-27
categories: 
  - db
tags:
  - [pl/sql, oracle, tibero, 대용량 데이터 삭제, 대용량 테이블 삭제]
permalink: /pl_sql/
toc: true
toc_sticky: true
toc_label: "Index"
---


대용량 테이블(4천만건) 데이터 비교적 안전하게(비교적) 삭제하는 방법을 공부하게되어 공유합니다.

## 1. 대용량 Delete Redo/Undo문제
 `Redo `  트랜잭션을 실행하다가 취소(롤백)할 경우를 대비해 원본 데이터를 **보관하는** 역할 
 `Undo `  실제로 수행한 **변경사항**(INSERT, DELETE 등)을 재현하기 위한 로그입니다.

DB에서는 매번 데이터가 변경될 때마다 `Undo`에 이전 상태를 **보관**하고 `Redo`에 변경 이력을 **기록**합니다.

대용량 DELETE 실행시 한 번의 트랜잭션으로 모든 데이터를 지우기 때문에 Undo에 보관해야되는 데이터와 Redo 로그에 기록해야할 데이터 등이 한꺼번에 몰리게 되어 **DB 성능 저하**가 일어날 수 있습니다. 특히 Undo 테이블스페이스 FULL이 발생하게 되면 DB는 트랜잭션을 지속할 수 없게되고 이미 진행 중이던 DELETE 작업을 롤백 하려고 시도하지만 Undo가 이미 Full 상태라 롤백조차 어려워 질 수 있습니다. 또한 다른 트랜 잭션이 신규로 실행되거나 커밋을 시도할 때도 Undo가 필요하기 때문에 대기현상이 발생할 수 있고 이는 DB 성능이 급격히 떨어지고 서비스 중단까지도 이어질 수 있습니다.

## 2. 배치 처리

전체 데이터를 한꺼번에 지우는 방식이 아닌 **N만 건씩** 나누어 여러 번에 걸쳐 DELETE+COMMIT을 수행하여 한꺼번에 몰리는 Undo/Redo 량을 줄어들게 하도록 하겠습니다.

## 3.  데이터 삭제
구분 값은 Date로 최근 1년 정도의 데이터(1천만건)만 남기고 모두 삭제해야한다.
한 번에 Delete를 하게되면 Undo/Redo 문제로 DB부담이 심해질 수 있어
일정 배치 크기로 나누어 트랜잭션 부하를 분산하고자 PL/SQL 사용
